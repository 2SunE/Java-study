### 컬렉션 프레임워크 📝

<h4>List 컬렉션</h4>
<ul>
	<li>배열과 비슷하게 객체를 인덱스로 관리한다.
		<ul>
			<li>배열과의 차이점은 저장용량이 자동으로 증가하며, 객체를 저장할 때 자동 인덱스가 부여된다.</li>
			<li>추가, 삭제, 검색을 위한 다양한 메소드들이 제공된다.</li>
		</ul>
	</li>
	<li>List 컬렉션은 객체 자체를 저장하는 것이 아니라 객체의 번지를 참조한다
		<ul>
			<li>동일한 객체를 중복 저장할 수 있는데, 이 경우 동일한 번지가 참조된다.</li>
			<li>null도 저장이 가능하며, 이 경우 해당 인덱스는 객체를 참조하지 않는다.</li>
		</ul>
	</li>
	<li>ArrayList
		<ul>
			<li>기본 생성자로 ArrayList 객체를 생성하면 내부에 10개의 객체를 저장할 수 있는 초기 용량을 가진다.</li>
			<li>저장되는 객체 수가 늘어나면 용량이 자동으로 증가한다.</li>
			<li>특정 인덱스의 객체를 제거하면 바로 뒤 인덱스부터 마지막 인덱스까지 모두 앞으로 1씩 당겨진다.</li>
			<li>마찬가지로 특정 인덱스에 객체를 삽입하면 해당 인덱스부터 마지막 인덱스까지 모두 1씩 밀려난다.
				<ul>
					<li>이런 동작 때문에 저장된 객체 수가 많고, 특정 인덱스에 객체를 추가하거나 제거하는 일이 빈번하다면 <br>
						ArrayList보다는 LinkedList를 사용하는 것이 좋다.	
					</li>
					<li>
						인덱스를 이용해서 객체를 찾거나 맨 마지막에 객체를 추가하는 경우에는 ArrayList가 더 좋은 성능을 발휘한다.
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>Vector
		<ul>
			<li>Vector는 ArrayList와 동일한 내부 구조를 가지고 있다.</li>
			<li>ArrayList와 다른 점은 동기화된(synchronized) 메소드로 구성되어 있다.
				<ul>
					<li>멀티 스레드가 동시에 Vector의 메소드를 실행할 수 없고, 하나의 스레드가 메소드 실행을 완료해야만<br>
						다른 스레드가 메소드를 실행할 수 있다.
					</li>
					<li>
						그래서 멀티 스레드 환경에서 안전하게 객체를 추가, 삭제할 수 있다. (thread safe)
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>LinkedList
		<ul>
			<li>List 구현 클래스이므로 ArrayList와 사용 방법은 똑같은데, 내부 구조는 완전 다르다.</li>
			<li>ArrayList는 내부 배열에 객체를 저장해서 관리하지만, LinkedList는 인접 참조를 링크해서 체인처럼 관리한다.
				<ul>
					<li>특정 인덱스의 객체를 제거하면 앞뒤 링크만 변경되고 나머지 링크는 변경되지 않는다.</li>
					<li>특정 인덱스에 객체를 삽입할 때에에도 마찬가지다.</li>
				</ul>
			</li>
			<li>끝에서부터(순차적) 추가 또는 삭제하는 경우는 ArrayList가 빠르지만,<br>
				중간에 추가, 삭제하는 경우는 앞뒤 링크 정보만 변경하는 LinkedList가 더 빠르다.
				<ul>
					<li>ArrayList는 뒤쪽 인덱스들을 모두 1씩 증가 또는 감소시키는 시간이 필요하므로 처리 속도가 느리다.</li>
				</ul>
			</li>
			<li>LinkedList가 처음 생성될 때에는 어떠한 링크도 만들어지지 않기 때문에 내부는 비어 있다고 보면 된다.</li>
		</ul>
	</li>
</ul>
